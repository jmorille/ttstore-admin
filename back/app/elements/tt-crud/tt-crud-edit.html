<link rel="import" href="../../components/core-style/core-style.html">


<link rel="import" href="../../components/core-ajax/core-ajax.html">
<link rel="import" href="../../components/core-icon/core-icon.html">


<link rel="import" href="tt-crud-menu.html">


<core-style id="tt-group-edit">
  .toast-error {
  background-color: {{g.paperInput.invalidColor}};
  }

</core-style>

<polymer-element name="tt-crud-edit" attributes="entityid data index">
  <template>

    <core-ajax id="service_get" url="/s/{{index}}/{{entityid}}" handleAs="json"
               contentType="application/json"
               response="{{data}}"
               method="GET"
               on-core-error="{{handleError}}"
               on-core-response="{{handleGetResponse}}">
    </core-ajax>
    <core-ajax id="service_save" url="/s/{{index}}/{{entityid}}" handleAs="json"
               contentType="application/json"
               body="{{dataToSaveString}}"
               method="{{serviceSaveVerb}}"
               on-core-error="{{handleSaveError}}"
               on-core-response="{{handleSaveResponse}}">
    </core-ajax>


    <core-style ref="tt-group-edit"></core-style>


    <tt-crud-menu save="{{isSaveEnabled}}"
                  on-tap-delete="{{onDelete}}" on-tap-save="{{onSaveButton}}" on-tap-close="{{onClose}}">

    </tt-crud-menu>

    <section vertical layout>
      <content id="content"></content>
    </section>


    <paper-toast id="toast_save_success" class="capsule" text="Entity Saved.">
      <core-icon icon="done"></core-icon>
    </paper-toast>
    <paper-toast id="toast_save_error" class="capsule toast-error" text="{{toastSaveErrorMessage}}">
      <core-icon icon="error"></core-icon>
    </paper-toast>

  </template>

  <script>
    Polymer('tt-crud-edit', {
      // Config
      autosave: '',
      autocreate: '',
      validateautofocus: '',
      // On Save : Reload the Data
      reloadOnSave: true,
      // Model
      entityid: '',
      data: undefined,
      dataOri: undefined,
      dataToSaveString: undefined,

      // Service
      serviceSaveVerb: undefined,

      // Crud Menu Status
      isSaveEnabled: true,

      // Toast Message
      toastSaveErrorMessage: undefined,

      // --- Life Cycle
      // --- ---------------
      ready: function () {
      },

      detached: function () {
      },

      // --- Data Observer
      // --- ---------------------
      attributeChanged: function (attrName, oldVal, newVal) {
        //var newVal = this.getAttribute(attrName);
        console.log(attrName, 'old: ' + oldVal, 'new:', newVal);
      },
      observe: {
        'data._version': 'dataChanged'
      },

      dataChanged: function (oldValue, newValue) {
        console.log("***************************");
        console.log(" Data Changed to : ", this.data);
        this.dataOri = JSON.parse(JSON.stringify(this.data));
        console.log("***************************");
      },
      entityidChanged: function (oldValue, newValue) {
        console.log("**//**//**//**//**//** entityidChanged : ", this.entityid);
        //console.log("entityidChanged for ", this.entityid);
        if (this.entityid === '' || this.entityid === null) {
          // Blank case, no model to create
        } else if (this.entityid === undefined) {
          // Create Mode
          this.data = this.createEmptyEntity();
          //  console.log("entityidChanged create empty data ", this.data);
        } else if (!this.data || !this.data._id || this.data._id !== this.entityid) {
          // Update Mode
          this.entityGet();
          //  console.log("entityidChanged load data ", this.entityid);
        }
      },

      // --- Actions
      // --- ---------------------
      onClose: function () {
//        var diff = this.diffProperties(this.dataOri._source, this.data._source);
//        if (diff) {
//            // TODO Show Popup
//            //  this.$.toast_save_not_need.show();
//            console.log("Diff detected, close refused !!!!")
//        } else {
        this.fire('cancel', this.entity);
//        }
      },

      onSaveButton: function () {
        console.log("----------- Click on save");
        this.save();
      },


      // --- Entity GET
      // --- ---------------------

      entityGet: function () {
        this.$.service_get.go();
      },

      handleError: function (resp) {
        this.fire("error", {
          error: resp,
          status: resp.status
        });
      },

      handleGetResponse: function (resp) {
        var detail = resp.detail;
        this.fire("entity-get", {
          response: detail.response,
          status: detail.xhr.status
        })
      },

      // --- Entity Save
      // --- ---------------------

      save: function () {
        //  var isValid = this.checkValidity();
        //   console.log("----------- check Validity ", isValid);
        // Dirty Check
        if (!this.isDiff(this.notifNotDiff.bind(this))) {
          return;
        }
        // Diff, need to save
        if (this.isModeCreate()) {
          this.entityCreate();
        } else {
          this.entityUpdate();
        }

      },

      isModeCreate: function () {
        return !this.data._id;
      },


      handleSaveResponse: function (resp) {
        var detail = resp.detail;
        var status = detail.xhr.status;
        var saveResult = detail.response;
        console.log("Save response", status, ":", resp);
        console.log("Save response detail", saveResult);
        if (status === 200) {
          // Check Existing id
          if (!this.data._id) {
            this.data._id = resp._id;
          }
          if (!this.entityid) {
            this.entityid = resp._id;
          }
          // Increment version or reload data ?
          if (this.reloadOnSave === '' || this.reloadOnSave === true) {
            console.log("Reload on save");
            this.entityGet();
          } else {
            // Update version
            console.log("Increment Version to ", resp._version, " for data", this.data);
            this.data._version = resp._version;
            // Clone the version by wathcing  change on data._version
          }
          // Show Notification
          this.$.toast_save_success.show();
        }
      },

      handleSaveError: function (event, detail, target) {
        // BUG ? detail.response as Text with status:JsonObj ? ==> Read from xhr
        console.log("Bug handleSaveError detail.response (Not JSON) : ", detail.response);
        var resp = JSON.parse(detail.xhr.response);
        var status = detail.xhr.status;
        if (status === 404) {
          // 404 Not Found
          this.showSaveErrorMessage('Entity Save Error : Entity Not Found');
          //this.entityNotFoundResolution(event, detail, target);
        } else if (status === 409) {
          // 409 : Conflict
          console.error("Entity Save Conflict", resp, detail.xhr);
          this.showSaveErrorMessage('Entity Save Conflict');
          // conflict resolution with reload data
          //this.onGet(this.conflictResolution(this, this.dataOri, this.data));
        } else {
          // Other Error
          console.error("handleSaveError", resp, detail.xhr);
          this.showSaveErrorMessage('Entity Save Error ' + status + ' : ' + detail.xhr.statusText);
          // Fire Event
          this.fire("error", {
            error: resp,
            status: status
          });
        }
      },


      // --- Entity Create
      // --- ---------------------

      createEmptyEntity: function () {
        return {
          _id: undefined,
          _version: undefined,
          _source: {}
        };
      },


      entityCreate: function () {
        var opt = {
          body: this.data._source
        };
        this.dataToSaveString = JSON.stringify(opt);
        console.log("************ entityCreate", this.data);
        console.log("************ entityCreate datastring", this.dataToSaveString);
        console.log("Request Create of ", opt);
        this.serviceSaveVerb = 'POST';
        this.$.service_save.go();
      },

      // --- Entity Update
      // --- ---------------------


      entityUpdate: function () {
        var opt = {
          version: this.data._version,
          body: {
            doc: this.data._source
          }
        };
        this.dataToSaveString = JSON.stringify(opt);
        console.log("Request Save of ", opt);
        this.serviceSaveVerb = 'PUT';
        this.$.service_save.go();
      },


      // --- Entity Validate
      // --- ---------------------

      checkValidity: function () {
        var childNodes = this.getFornInputField();
        console.log("checkValidity Nodes of ", childNodes);
        var errorNodes = Array.prototype.filter.call(childNodes, function (childNode) {
          if (typeof childNode['checkValidity'] === 'function') {
            return !childNode['checkValidity']();
          }
          return false;
        });
        return true;
      },
      getFornInputField: function () {
        console.dir(this.$.content);
        // Bug ? https://github.com/Polymer/polymer/issues/414
        // var childNodes = this.$.content.querySelectorAll('*');
        // https://github.com/Polymer/paper-input/commit/255980d5400ef5aada1af87f1771d77c436f469e
        var childNodes = this.$.content.getDistributedNodes();
        console.log("getFornInputField Nodes of ", childNodes);
        var inputFieldNodes = Array.prototype.filter.call(childNodes, function (childNode) {
          console.log("Test Validity Nodes of ", childNode.tagName);
          var childTagName = childNode.tagName;
          if (typeof childNode['checkValidity'] === 'function') {
            console.log("childNode", childNode);
            return true;
            validate
          } else if (typeof childNode['validate'] === 'function') {
            console.log("childNode", childNode);
            return true;
          }

          return false;
        });
        return inputFieldNodes;
      },


      onFormInvalid: function (e) {
        e.detail.forEach(function (badEl) {
          // handle invalid element
          console.log("invalid element", badEl);
        });
      },

      // --- Data Differential
      // --- ---------------------

      isEmptyObj: function (obj) {
        return (Object.getOwnPropertyNames(obj).length === 0);
      },

      diffProperties: function (first, second, diffs) {
        diffs = diffs || {};
        // Compare ref to Object
        for (var attr in second) {
          if (Array.isArray(first[attr]) && Array.isArray(second[attr])) {
            if (first[attr] !== second[attr]) {
              diffs[attr] = second[attr];
            }
          } else if (typeof first[attr] == 'object' && typeof second[attr] == 'object') {
            // Check recursif
            var subDiffs = this.diffProperties(first[attr], second[attr], {});
            if (subDiffs) {
              diffs[attr] = subDiffs;
            }
          } else if (first[attr] !== second[attr]) {
            diffs[attr] = second[attr];
          }
        }
        return this.isEmptyObj(diffs) ? undefined : diffs;
      },

      isDiff: function (notDiffCallback) {
        var diff = this.diffProperties(this.dataOri._source, this.data._source);
        if (notDiffCallback) {
          notDiffCallback(diff);
        }
        return diff;
      },

      notifNotDiff: function (diff) {
        if (!diff) {
          this.showSaveErrorMessage("Saved not needed.");
        }
      },

      // --- Toasts
      // --- ---------------------
      showSaveErrorMessage: function (msg) {
        this.toastSaveErrorMessage = msg;
        this.$.toast_save_error.show();
      }


      // --- Others
      // --- ---------------------


    });

  </script>
</polymer-element>
