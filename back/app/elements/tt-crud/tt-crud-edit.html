<link rel="import" href="../../components/core-style/core-style.html">


<link rel="import" href="../../components/core-ajax/core-ajax.html">
<link rel="import" href="../../components/core-icon/core-icon.html">


<link rel="import" href="tt-crud-server.html">
<link rel="import" href="tt-crud-menu.html">
<link rel="import" href="tt-crud-conflictresolution.html">

<core-style id="tt-group-edit">
  .toast-error {
  background-color: {{g.paperInput.invalidColor}};
  }

</core-style>

<polymer-element name="tt-crud-edit" attributes="entityid data index">
  <template>
    <tt-crud-server id="server" role="database"
                    on-get-response="{{handleGetResponse}}" on-get-error="{{handleGetError}}"
                    on-save-response="{{handleSaveResponse}}" on-save-error="{{handleSaveError}}"
                    entityid="{{entityid}}" data="{{data}}" index="{{index}}">
    </tt-crud-server>

    <tt-crud-conflictresolution id="conflict_resolution" data="{{data}}"
                                dataOri="{{dataOri}}"></tt-crud-conflictresolution>

    <core-style ref="tt-group-edit"></core-style>


    <tt-crud-menu save="{{isSaveEnabled}}"
                  on-tap-delete="{{onDelete}}" on-tap-save="{{onSaveButton}}" on-tap-close="{{onClose}}">

    </tt-crud-menu>

    <section vertical layout>
      <content id="content"></content>
    </section>


    <paper-toast id="toast_save_success" class="capsule" text="Entity Saved.">
      <core-icon icon="done"></core-icon>
    </paper-toast>
    <paper-toast id="toast_save_error" class="capsule toast-error" text="{{toastSaveErrorMessage}}">
      <core-icon icon="error"></core-icon>
    </paper-toast>

  </template>

  <script>
    Polymer('tt-crud-edit', {
      // Config
      autosave: '',
      autocreate: '',
      validateautofocus: '',
      // On Save : Reload the Data
      reloadOnSave: true,
      // Model
      entityid: '',
      data: undefined,
      dataOri: undefined,

      // Crud Menu Status
      isSaveEnabled: true,

      // Toast Message
      toastSaveErrorMessage: undefined,

      // --- Life Cycle
      // --- ---------------
      ready: function () {
      },

      detached: function () {
      },

      // --- Data Observer
      // --- ---------------------

//      observe: {
//        'data._version': 'dataChanged'
//      },
//
//      dataChanged: function (oldValue, newValue) {
//        console.log("***************************");
//        console.log(" Data Changed to : ", this.data);
//        this.dataOri = JSON.parse(JSON.stringify(this.data));
//        console.log("***************************");
//      },
      dataSnapshot: function () {
        console.log("***************************");
        console.log(" Data Changed to : ", this.data);
        this.dataOri = JSON.parse(JSON.stringify(this.data));
        console.log("***************************");
      },

      entityidChanged: function (oldValue, newValue) {
        console.log("**//**//**//**//**//** entityidChanged : ", this.entityid);
        //console.log("entityidChanged for ", this.entityid);
        if (this.entityid === '' || this.entityid === null) {
          // Blank case, no model to create
        } else if (this.entityid === undefined) {
          // Create Mode
          this.data = this.$.server.createEmptyEntity();
          //  console.log("entityidChanged create empty data ", this.data);
        } else if (!this.data || !this.data._id || this.data._id !== this.entityid) {
          // Update Mode
          this.entityGet();
          //  console.log("entityidChanged load data ", this.entityid);
        }
      },

      // --- Actions
      // --- ---------------------
      onClose: function () {
//        var diff = this.diffProperties(this.dataOri._source, this.data._source);
//        if (diff) {
//            // TODO Show Popup
//            //  this.$.toast_save_not_need.show();
//            console.log("Diff detected, close refused !!!!")
//        } else {
        this.fire('cancel', this.entity);
//        }
      },

      onSaveButton: function () {
        console.log("----------- Click on save");
        this.save();
      },


      // --- Entity GET
      // --- ---------------------

      entityGet: function () {
        this.$.server.entityGet();
      },

      handleGetResponse: function (event, detail, target) {
        console.log("handleGetResponse : ", detail);
        // Data Snapshot
        this.dataSnapshot();
        // Resolve conflict is Needed
        if (this.$.conflict_resolution && this.$.conflict_resolution.isCurrentConflict()) {
          var userDiff = this.$.conflict_resolution.mergeConflict();
          if (userDiff.userDiffConflict) {
            // TODO Real Conflict without resolution ??
          }
        }
        // Fire Event
        this.fire("entity-get", {
          response: detail.response,
          status: detail.status,
          statusText: detail.statusText
        });
      },

      handleGetError: function (event, detail, target) {
        console.log("handleGetError : ", detail);
        this.fire("entity-get-error", {
          response: detail.response,
          status: detail.status,
          statusText: detail.statusText
        });
      },


      // --- Entity Save
      // --- ---------------------

      save: function () {
        // Dirty Check
        if (!this.isDiff(this.notifNotDiff.bind(this))) {
          return;
        }
        // Validation
        if (!this.checkValidity(this.notifValidityErrors.bind(this))) {
          return;
        }

        // Diff, need to save
        if (this.isModeCreate()) {
          this.entityCreate();
        } else {
          this.entityUpdate();
        }
      },

      isModeCreate: function () {
        return !this.data._id;
      },


      handleSaveResponse: function (event, detail, target) {
        var status = detail.status;
        var saveResult = detail.response;
        console.log("Save response", status, ":", saveResult);
        if (status === 200) {
          // Check Existing id
          if (!this.data._id) {
            this.data._id = resp._id;
          }
          if (!this.entityid) {
            this.entityid = resp._id;
          }
          // Increment version or reload data ?
          if (this.reloadOnSave === '' || this.reloadOnSave === true) {
            console.log("Reload on save");
            this.entityGet();
          } else {
            // Update version
            console.log("Increment Version to ", saveResult._version, " for data", this.data);
            this.data._version = saveResult._version;
            // Clone the version by wathcing  change on data._version
            // Data Snapshot
            this.dataSnapshot();
          }
          // Show Notification
          this.$.toast_save_success.show();
        }
      },

      handleSaveError: function (event, detail, target) {
        // BUG ? detail.response as Text with status:JsonObj ? ==> Read from xhr
        console.log("Bug handleSaveError detail.response (Not JSON) : ", detail.response);
        var resp = detail.response;
        var status = detail.status;
        console.log('Entity Save Error', status, ':', detail.statusText, ',', resp);
        if (status === 404) {
          // 404 Not Found
          this.showSaveErrorMessage('Entity Save Error : Entity Not Found');
          //this.entityNotFoundResolution(event, detail, target);
        } else if (status === 409) {
          // 409 : Conflict
          this.showSaveErrorMessage('Entity Save Conflict');
          // conflict resolution with reload data
          this.resolveConflict();
        } else {
          // Other Error
          this.showSaveErrorMessage('Entity Save Error ' + status + ' : ' + detail.statusText);
          // Fire Event
          this.fire("entity-save-error", {
            response: resp,
            status: status
          });
        }
      },

      // --- Conflict Resolution
      // --- ---------------------
      resolveConflict: function () {
        if (this.$.conflict_resolution) {
          this.$.conflict_resolution.markToConflictToBeResolve();
        }
        this.entityGet();
      },

      // --- Entity Create
      // --- ---------------------

      entityCreate: function () {
        this.$.server.entityCreate();
      },

      // --- Entity Update
      // --- ---------------------


      entityUpdate: function () {
        this.$.server.entityUpdate();
      },


      // --- Entity Validate
      // --- ---------------------

      checkValidity: function (errorCallback) {
        var childNodes = this.getFornInputField();
        console.log("checkValidity Nodes of ", childNodes);

        var errorNodes = Array.prototype.filter.call(childNodes, function (childNode) {
          if (typeof childNode['checkValidity'] === 'function') {
            return !childNode['checkValidity']();
          } else if (typeof childNode['validate'] === 'function') {
            return !childNode['validate']();
          }
          return false;
        });
        console.log("checkValidity Errors Nodes : ", errorNodes);
        // Error Callback
        if (errorCallback) {
          errorCallback(errorNodes);
        }
        // Return
        return errorNodes.length < 1;
      },

      getFornInputField: function (childNodes) {
        childNodes = childNodes || this.$.content.getDistributedNodes();
        // Bug ? https://github.com/Polymer/polymer/issues/414
        // var childNodes = this.$.content.querySelectorAll('*');
        // https://github.com/Polymer/paper-input/commit/255980d5400ef5aada1af87f1771d77c436f469e
        // console.log("getFornInputField Nodes of ", childNodes);
        var that = this;
        var inputFieldNodes = Array.prototype.reduce.call(childNodes, function (acc, childNode) {
          var childTagName = childNode.tagName;
          if (typeof childNode['checkValidity'] === 'function') {
            console.log("childNode", childNode);
            acc.push(childNode);
          } else if (typeof childNode['validate'] === 'function') {
            console.log("childNode", childNode);
            acc.push(childNode);
          } else if ((childNode.childNodes !== undefined) && (childNode.childNodes.length > 0)) {
            var subNodes = that.getFornInputField(childNode.childNodes);
            if ((subNodes !== undefined) && (subNodes.length > 0)) {
              Array.prototype.push.apply(acc, subNodes);
            }
          }
          return acc;
        }, []);

        return inputFieldNodes;
      },


      onFormInvalid: function (e) {
        e.detail.forEach(function (badEl) {
          // handle invalid element
          console.log("invalid element", badEl);
        });
      },

      notifValidityErrors: function (errorNodes) {
        if (errorNodes && errorNodes.length > 0) {
          if (this.validateautofocus === '' || this.validateautofocus === true) {
            var errorNode = errorNodes[0];
            console.log("request focus on ", errorNode.tagName, errorNode);
            if ('PAPER-INPUT-DECORATOR' === errorNode.tagName) {
              if (errorNode && errorNode.input) {
                errorNode.input.focus();
              }
            } else if (typeof errorNode['focus'] === 'function') {
              errorNode.focus();
            }

          }
          this.showSaveErrorMessage("Error in validate Entity");
        }
      },

      // --- Data Differential
      // --- ---------------------

      isEmptyObj: function (obj) {
        return (Object.getOwnPropertyNames(obj).length === 0);
      },

      diffProperties: function (first, second, diffs) {
        diffs = diffs || {};
        // Compare ref to Object
        for (var attr in second) {
          if (Array.isArray(first[attr]) && Array.isArray(second[attr])) {
            if (first[attr] !== second[attr]) {
              diffs[attr] = second[attr];
            }
          } else if (typeof first[attr] == 'object' && typeof second[attr] == 'object') {
            // Check recursif
            var subDiffs = this.diffProperties(first[attr], second[attr], {});
            if (subDiffs) {
              diffs[attr] = subDiffs;
            }
          } else if (first[attr] !== second[attr]) {
            diffs[attr] = second[attr];
          }
        }
        return this.isEmptyObj(diffs) ? undefined : diffs;
      },

      isDiff: function (notDiffCallback) {
        var diff = this.diffProperties(this.dataOri._source, this.data._source);
        if (notDiffCallback) {
          notDiffCallback(diff);
        }
        return diff;
      },

      notifNotDiff: function (diff) {
        if (!diff) {
          this.showSaveErrorMessage("Saved not needed.");
        }
      },

      // --- AutoSave
      // --- ---------------------
      addInputWatcher: function (focusAction, blurAction) {
        var childNodes = this.getFornInputField();
        var that = this;
        console.log("---------- addInputWatcher", childNodes);
        childNodes.forEach(function (elt) {
          var focusable = elt;
          if ('PAPER-INPUT-DECORATOR' === elt.tagName) {
            focusable = elt.input;
          }
          // Delegate focus/blur events
          Polymer.addEventListener(focusable, 'input', this.focusAction.bind(this), true);
          Polymer.addEventListener(focusable, 'blur', this.blurAction.bind(this), true);
        });
        for (var i = 0; i < childNodes.length; i++) {
          var childNode = childNodes[i];
          console.log("---------- addInputWatcher", childNode);
          childNode.addEventListener('blur', this.blurListener);
          childNode.addEventListener('input', this.focusListener);
        }

      },


      inputFieldBlur: function (event) {
        console.log("*** Blur ", event);
        var autosave = this.isModeCreate() ? (this.autocreate === '' || this.autocreate === true) : ( this.autosave === '' || this.autosave === true );
        // Auto save
        if (autosave) {
          this.job('save', function () {
            this.onSave();
          }, 200);
        }
      },
      inputFieldFocus: function (event) {
        //  console.log("*** Focus " , event);
        this.isSaveEnabled = true;
      },

      // --- Toasts
      // --- ---------------------

      showSaveErrorMessage: function (msg) {
        this.toastSaveErrorMessage = msg;
        this.$.toast_save_error.show();
      }



      // --- Others
      // --- ---------------------


    });

  </script>
</polymer-element>
