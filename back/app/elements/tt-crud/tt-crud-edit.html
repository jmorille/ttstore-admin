<link rel="import" href="../../components/paper-input/paper-input.html">

<link rel="import" href="../../components/core-style/core-style.html">

<link rel="import" href="../../components/paper-toast/paper-toast.html">

<link rel="import" href="tt-crud-menu.html">


<core-style id="tt-group-edit">
    .toast-error {
    background-color: {{g.paperInput.invalidColor}};
    }


</core-style>

<polymer-element name="tt-crud-edit" attributes="entityid data">
<template>

    <core-style ref="tt-group-edit"></core-style>


    <tt-crud-menu save="{{isSaveEnabled}}"
                  on-tap-delete="{{onDelete}}" on-tap-save="{{onSaveButton}}" on-tap-close="{{onClose}}">

    </tt-crud-menu>


    <paper-toast id="toast_save_ok" class="capsule" text="Entity Save."></paper-toast>
    <paper-toast id="toast_save_not_need" class="capsule" text="Nothing to Save."></paper-toast>

    <paper-toast id="toast_delete_ok" class="capsule" text="Entity Deleted."></paper-toast>


    <paper-toast id="toast_entity_notfound" class="capsule toast-error" text="Entity Not Found"></paper-toast>

    <paper-toast id="toast_save_ko" class="capsule toast-error" text="Error in saving Entity"></paper-toast>
    <paper-toast id="toast_save_ko_conflict" class="capsule toast-error"
                 text="Conflict in saving Entity"></paper-toast>

    <paper-toast id="toast_validate_ko" class="capsule toast-error" text="Error in validate Entity"></paper-toast>


</template>

<script>
Polymer('tt-crud-edit', {
    // Config
    autosave: '',
    autocreate: '',
    validateautofocus : '',
    // On Save : Reload the Data
    reloadOnSave: false,
    // Model
    entityid: '',
    data: data = undefined,
    dataOri: undefined,
    // Crud Menu Status
    isSaveEnabled: false,

    //
    ready: function () {
        // Create Binding listener for Blur and Focus
        this.blurListener = this.inputFieldBlur.bind(this);
        this.focusListener = this.inputFieldFocus.bind(this);
        this.addInputWatcher();
    },

    detached: function () {
        // Remove Binding listener for Blur and Focus
        this.removeInputWatcher();
    },

    observe: {
        'data._version': 'dataChanged'
    },

    createEmptyEntity: function () {
        return {
            _id: undefined,
            _version: undefined,
            _source: {}
        };
    },

    entityidChanged: function (oldValue, newValue, args) {
        //console.log("entityidChanged for ", this.entityid);
        if (this.entityid === '' || this.entityid === null) {
            // Blank case, no model to create
        } else if (this.entityid === undefined) {
            // Create Mode
            this.data = this.createEmptyEntity();
            //  console.log("entityidChanged create empty data ", this.data);
        } else if (!this.data || !this.data._id || this.data._id !== this.entityid) {
            // Update Mode
            this.onGet();
            //  console.log("entityidChanged load data ", this.entityid);
        }
    },
    dataChanged: function (oldValue, newValue, args) {

        // call also for _version change=
        //   console.log("--- dataChanged for ", this.data);
        // Clone the data for conflict resolution
        this.dataOri = this.$.service.copyProperties(this.data);
        // Manage the bar
//        if (this.data._source) {
//            this.$.deleteButton.removeAttribute('disabled' );
//            this.$.saveButton.removeAttribute('disabled' );
//        } else {
//            this.$.deleteButton.setAttribute('disabled', 'true');
//            this.$.saveButton.setAttribute('disabled', false);
//        }

    },


    isEmptyObj: function (obj) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    },
    onGet: function (callback) {
        this.$.service.entityGet({_id: this.entityid}, callback);
    },
    onSaveButton: function () {
        console.log("### onSave Button");
        var toastCallback = this.notifValidityErrors.bind(this);
        var validationCallback = function (errorNodes) {
            if (errorNodes && errorNodes.length > 0) {
                console.log("On Save Button Error ", errorNodes.length);
                errorNodes[0].focus();
            }
            toastCallback(errorNodes);
        };
        if (this.onSave(validationCallback)) {
            this.fire('save', this.entity);
        }
    },
    isModeCreate : function () {
       return !this.data._id;
    },

    onSave: function (validationCallback) {
//        var cb = validationCallback;
//        if (cb === undefined) {
//            cb =   this.notifValidityErrors.bind(this);
//        }
        validationCallback = validationCallback || this.notifValidityErrors.bind(this);

        if (this.isValid(validationCallback)) {
            // Compute Diff
            if (this.isDiff(this.notifNotDiff.bind(this))) {
                // Save Or Create
                if (this.isModeCreate()) {
                    this.$.service.entityCreate();
                } else {
                    this.$.service.entityUpdate();
                }
            }
        } else {
            return false;
        }
        return true;
    },
    crudDeleteHandler: function (event, detail, target) {
        console.log("## toast_delete_ok");
        this.$.toast_delete_ok.show();
        this.entityid = '';
    },

    crudSaveHandler: function (event, detail, target) {
        // Update or Create
        var resp = detail.response;
        // Check Existing id
        if (!this.data._id) {
            this.data._id = resp._id;
        }
        if (!this.entityid) {
            this.entityid = resp._id;
        }
        // Increment version or reload data ?
        if (this.reloadOnSave === '' || this.reloadOnSave === true) {
            console.log("Reload on save");
            this.onGet();
            this.$.service.entityGet({_id: resp._id});
        } else {
            // Update version
            console.log("Increment Version to ", resp._version, " for data", this.data);
            this.data._version = resp._version;
            // Clone the version by wathcing  change on data._version
        }
        // Show Notification
        this.isSaveEnabled = false;
        console.log("## toast_save_ok");
        this.$.toast_save_ok.show();

    },

    crudErrorHandler: function (event, detail, target) {
        var err = detail.error;
        var resp = detail.response;
        var status = detail.status;
        if (status === 404) {
            // 404 Not Found
            console.log("## toast_entity_notfound");
            this.$.toast_entity_notfound.show();
            this.entityNotFoundResolution(event, detail, target);
        } else if (status === 409) {
            // 409 : Conflict
            console.log("## toast_save_ko_conflict");
            this.$.toast_save_ko_conflict.show();
            // conflict resolution with reload data
            this.onGet(this.conflictResolution(this, this.dataOri, this.data));
        } else {
            // Other Error
            console.error("crudErrorHandler", err);
            console.log("## toast_save_ko");
            this.$.toast_save_ko.show();
        }
    },
    entityNotFoundResolution: function (event, detail, target) {
        console.log("## entityNotFoundResolution");

        this.$.toast_entity_notfound.show();
        this.job('entity_notfound', function () {
            this.entityid = '';
            this.fire('cancel');
        }, 2000);
    },
    conflictResolution: function (that, dataOri, data) {
        return function (err, resp) {
            if (!err) {
                var diffUser = that.diffProperties(dataOri._source, data._source);
                var difServer = that.diffProperties(dataOri._source, resp._source);
                // Compute confliect
                var difConflict = that.existProperties(difServer, diffUser);
                var difMergeable = that.notExistProperties(difServer, diffUser);
                console.log("---------- Conflict resolution");
                console.log("Diff User", diffUser);
                console.log("Diff Server", difServer);
                console.log("---------- ");
                console.log("Conflict User-Server", difConflict);
                console.log("Mergeable User", difMergeable);
                console.log("---------- ");
                // Merge Not Conflict
                if (difMergeable) {
                    for (var attr in difMergeable) {
                        that.data._source[attr] = difMergeable[attr];
                    }
                }
                if (difConflict) {
                    // TODO Conflict
                }
                console.log("---------- Conflict resolution END");
            }
        }
    },
    existProperties: function (server, client, conflict) {
        conflict = conflict || {};
        console.log("existProperties", "server", server, " // client", client);
        if (client) {
            for (var attr in server) {
                if (server.hasOwnProperty(attr) && client.hasOwnProperty(attr)) {
                    conflict[attr] = client[attr];
                }
            }
        }
        return this.isEmptyObj(conflict) ? undefined : conflict;
    },
    notExistProperties: function (server, client, conflict) {
        conflict = conflict || {};
        if (client) {
            for (var attr in client) {
                if (client.hasOwnProperty(attr) && !server.hasOwnProperty(attr)) {
                    conflict[attr] = client[attr];
                }
            }
        }
        return this.isEmptyObj(conflict) ? undefined : conflict;
    },
    notifValidityErrors: function (errorNodes) {
        if (errorNodes && errorNodes.length >0 ) {
            if (this.validateautofocus === '' || this.validateautofocus === true) {
                errorNodes[0].focus();
            }
            console.log("## toast_validate_ko");
            this.$.toast_validate_ko.show();
        }
    },
    notifNotDiff: function () {
//        this.job('toast_save_not_need', function () {
//            this.$.toast_save_not_need.show();
//        }, 100);
    },

    onDelete: function () {
        console.log("Entity Delete");
        if (this.data._id) {
            this.$.service.entityDelete(this.data);
        } else {
            this.fire('cancel', this.entity);
        }
    },

    onClose: function () {
//        var diff = this.diffProperties(this.dataOri._source, this.data._source);
//        if (diff) {
//            // TODO Show Popup
//            //  this.$.toast_save_not_need.show();
//            console.log("Diff detected, close refused !!!!")
//        } else {
        this.fire('cancel', this.entity);
//        }
    },

    getFornInputField: function () {
        var childNodes = this.shadowRoot.querySelectorAll('#editForm > *');
        var inputFieldNodes = Array.prototype.filter.call(childNodes, function (childNode) {
             if (typeof childNode['checkValidity'] === 'function') {
                 console.dir("childNode", childNode);
                return true;
            };
            return false;
        });
        return inputFieldNodes;
    },

    isValid: function (errorCallback) {
        var valid = true;
        var childNodes = this.getFornInputField();
        var errorNodes = Array.prototype.filter.call(childNodes, function (childNode) {
            if (typeof childNode['checkValidity'] === 'function') {
                return  !childNode['checkValidity']();
            }
            return false;
        });
        if (!errorNodes || errorNodes.length > 0) {
            // errorNodes[0].focus();
            valid = false;
        } else {
            errorNodes = undefined;
        }
        if (errorCallback) {
            errorCallback(errorNodes);
        }
        return valid;
    },
    isDiff: function (notDiffCallback) {
        var diff = this.diffProperties(this.dataOri._source, this.data._source);
        if (diff) {
            return true;
        } else {
            if (notDiffCallback) {
                notDiffCallback();
            }
        }
    },

    diffProperties: function (first, second, diffs) {
        diffs = diffs || {};
        // Compare ref to Object
        for (var attr in second) {
            if (Array.isArray(first[attr]) && Array.isArray(second[attr])) {
                if (first[attr] !== second[attr]) {
                    diffs[attr] = second[attr];
                }
            } else if (typeof first[attr] == 'object' && typeof second[attr] == 'object') {
                // Check recursif
                var subDiffs = this.diffProperties(first[attr], second[attr], {});
                if (subDiffs) {
                    diffs[attr] = subDiffs;
                }
            } else if (first[attr] !== second[attr]) {
                diffs[attr] = second[attr];
            }
        }
        return this.isEmptyObj(diffs) ? undefined : diffs;
    },

    addInputWatcher: function () {
        var childNodes = this.getFornInputField();
         console.log("---------- addInputWatcher", childNodes);
        for (var i = 0; i < childNodes.length; i++) {
            var childNode = childNodes[i];
            console.log("---------- addInputWatcher", childNode);
            childNode.addEventListener('blur', this.blurListener);
            childNode.addEventListener('input', this.focusListener);
        }
        ;
    },
    removeInputWatcher: function () {
        var childNodes = this.getFornInputField();
        //  console.log("---------- removeInputWatcher", childNodes);
        for (var i = 0; i < childNodes.length; i++) {
            var childNode = childNodes[i];
            //  console.log("---------- removeInputWatcher", childNode);
            childNode.removeElementListener('blur', this.blurListener);
            childNode.removeElementListener('input', this.focusListener);
        }
        ;
    },
    inputFieldBlur: function (event) {
        console.log("*** Blur ", event);
        var autosave = this.isModeCreate() ? (this.autocreate === '' ||  this.autocreate === true) :  ( this.autosave === ''  || this.autosave === true );
        // Auto save
        if (autosave) {
            this.job('save', function () {
                this.onSave();
            }, 200);
        }
    },
    inputFieldFocus: function (event) {
        //  console.log("*** Focus " , event);
        this.isSaveEnabled = true;

    }


});

</script>
</polymer-element>