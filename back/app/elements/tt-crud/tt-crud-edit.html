<link rel="import" href="../../components/paper-input/paper-input.html">

<link rel="import" href="../../components/core-style/core-style.html">

<link rel="import" href="../../components/paper-toast/paper-toast.html">

<link rel="import" href="tt-crud-menu.html">


<core-style id="tt-group-edit"  >
    .toast-error {
    background-color: {{g.paperInput.invalidColor}};
    }
</core-style>

<polymer-element name="tt-crud-edit" attributes="entityid data">
<template>

    <core-style ref="tt-group-edit"></core-style>

    <tt-crud-menu on-tap-delete="{{onDelete}}" on-tap-save="{{onSave}}"  on-tap-close="{{onClose}}" ></tt-crud-menu>



    <paper-toast id="toast_save_ok" class="capsule" text="Entity Save."></paper-toast>
    <paper-toast id="toast_save_not_need" class="capsule" text="Nothing to Save."></paper-toast>

    <paper-toast id="toast_delete_ok" class="capsule" text="Entity Deleted."></paper-toast>


    <paper-toast id="toast_entity_notfound" class="capsule toast-error" text="Entity Not Found"></paper-toast>

    <paper-toast id="toast_save_ko" class="capsule toast-error" text="Error in saving Entity"></paper-toast>
    <paper-toast id="toast_save_ko_conflict" class="capsule toast-error"
                 text="Conflict in saving Entity"></paper-toast>

    <paper-toast id="toast_validate_ko" class="capsule toast-error" text="Error in validate Entity"></paper-toast>


</template>

<script>
Polymer('tt-crud-edit', {
    entityid: '',
    data: data = undefined,
    dataOri: undefined,
    // On Save : Reload the Data
    reloadOnSave: false,
    ready: function () {

    },
    observe: {
        'data._version': 'dataChanged'
    },

    createEmptyEntity: function () {
        return {
            _id: undefined,
            _version: undefined,
            _source: {}
        };
    },

    entityidChanged: function () {
        console.log("entityidChanged for ", this.entityid);
        if (this.entityid === '') {
            // Blank case, no model to create
        } else if (!this.entityid) {
            // Create Mode
            this.data = this.createEmptyEntity();
            console.log("entityidChanged create empty data ", this.data);
        } else if (!this.data || !this.data._id || this.data._id !== this.entityid) {
            // Update Mode
            this.onGet();
            console.log("entityidChanged load data ", this.entityid);
        }
    },
    dataChanged: function () {
        // call also for _version change=
        console.log("--- dataChanged for ", this.data);
        // Clone the data for conflict resolution
        this.dataOri = this.$.service.copyProperties(this.data);
        // Manage the bar
//        if (this.data._source) {
//            this.$.deleteButton.removeAttribute('disabled' );
//            this.$.saveButton.removeAttribute('disabled' );
//        } else {
//            this.$.deleteButton.setAttribute('disabled', 'true');
//            this.$.saveButton.setAttribute('disabled', false);
//        }

    },


    isEmptyObj: function (obj) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    },
    onGet: function (callback) {
        this.$.service.entityGet({_id: this.entityid}, callback);
    },

    onSave: function () {
        if (this.isValid(this.notifValidityErrors.bind(this))) {
            // Compute Diff
            if (this.isDiff(this.notifNotDiff.bind(this))) {
                // Save Or Create
                if (this.data._id) {
                    console.log("---- Update entity :", this.data);
                    this.$.service.entityUpdate(this.data);
                } else {
                    console.log("---- Create entity :", this.data);
                    this.$.service.entityCreate(this.data);
                }
            }
            // this.fire('save', this.entity);
        }
    },
    crudDeleteHandler: function (event, detail, target) {
        this.$.toast_delete_ok.show();
        this.entityid = '';
    },

    crudSaveHandler: function (event, detail, target) {
        // Update or Create
        var resp = detail.response;
        // Check Existing id
        if (!this.data._id) {
            this.data._id = resp._id;
        }
        if (!this.entityid) {
            this.entityid = resp._id;
        }
        // Increment version or reload data ?
        if (this.reloadOnSave) {
            console.log("Reload on save");
            this.onGet();
            this.$.service.entityGet({_id: resp._id});
        } else {
            // Update version
            console.log("Increment Version to ", resp._version, " for data", this.data);
            this.data._version = resp._version;
            // Clone the version by wathcing  change on data._version
        }
        // Show Notification
        this.$.toast_save_ok.show();

    },

    crudErrorHandler: function (event, detail, target) {
        var err = detail.error;
        var resp = detail.response;
        var status = detail.status;
        if (status === 404) {
            // 404 Not Found
            this.$.toast_entity_notfound.show();
            this.entityNotFoundResolution(event, detail, target);
        } else if (status === 409) {
            // 409 : Conflict
            this.$.toast_save_ko_conflict.show();
            // conflict resolution with reload data
            this.onGet(this.conflictResolution(this, this.dataOri, this.data));
        } else {
            // Other Error
            console.error("crudErrorHandler", err);
            this.$.toast_save_ko.show();
        }
    },
    entityNotFoundResolution: function (event, detail, target) {
        this.$.toast_entity_notfound.show();
        this.job('entity_notfound', function () {
            this.entityid = '';
            this.fire('cancel');
        }, 2000);
    },
    conflictResolution: function (that, dataOri, data) {
        return function (err, resp) {
            if (!err) {
                var diffUser = that.diffProperties(dataOri._source, data._source);
                var difServer = that.diffProperties(dataOri._source, resp._source);
                // Compute confliect
                var difConflict = that.existProperties(difServer, diffUser);
                var difMergeable = that.notExistProperties(difServer, diffUser);
                console.log("---------- Conflict resolution");
                console.log("Diff User", diffUser);
                console.log("Diff Server", difServer);
                console.log("---------- ");
                console.log("Conflict User-Server", difConflict);
                console.log("Mergeable User", difMergeable);
                console.log("---------- ");
                // Merge Not Conflict
                if (difMergeable) {
                    for (var attr in difMergeable) {
                        that.data._source[attr] = difMergeable[attr];
                    }
                }
                if (difConflict) {
                    // TODO Conflict
                }
                console.log("---------- Conflict resolution END");
            }
        }
    },
    existProperties: function (server, client, conflict) {
        conflict = conflict || {};
        console.log("existProperties", "server", server, " // client", client);
        if (client) {
            for (var attr in server) {
                if (server.hasOwnProperty(attr) && client.hasOwnProperty(attr)) {
                    conflict[attr] = client[attr];
                }
            }
        }
        return this.isEmptyObj(conflict) ? undefined : conflict;
    },
    notExistProperties: function (server, client, conflict) {
        conflict = conflict || {};
        if (client) {
            for (var attr in client) {
                if (client.hasOwnProperty(attr) && !server.hasOwnProperty(attr)) {
                    conflict[attr] = client[attr];
                }
            }
        }
        return this.isEmptyObj(conflict) ? undefined : conflict;
    },
    notifValidityErrors: function (errorNodes) {
        this.$.toast_validate_ko.show();
    },
    notifNotDiff: function () {
        this.job('toast_save_not_need', function () {
            this.$.toast_save_not_need.show();
        }, 100);
    },

    onDelete: function () {
        console.log("Entity Delete");
        if (this.data._id) {
            this.$.service.entityDelete(this.data);
        } else {
            this.fire('cancel', this.entity);
        }
    },

    onClose: function () {
        var diff = this.diffProperties(this.dataOri._source, this.data._source);
        if (diff) {
            // TODO Show Popup
            //  this.$.toast_save_not_need.show();
            console.log("Diff detected, close refused !!!!")
        } else {
            this.fire('cancel', this.entity);
        }
    },

    isValid: function (errorCallback) {
        var childNodes = this.shadowRoot.querySelectorAll('#editForm > *');
        var nodeFocus = undefined;
        var errorNodes = [];
        var valid = true;
        [].forEach.call(childNodes, function (childNode, i) {
            if (typeof childNode['checkValidity'] == 'function') {
                console.dir(childNode);
                var isFieldValid = childNode['checkValidity']();
                if (!isFieldValid) {
                    valid = false;
                    errorNodes.push(childNode);
                    if (!nodeFocus) {
                        nodeFocus = childNode;
                    }
                }
            }
        });
        if (nodeFocus) {
            nodeFocus.focus();
        }

        if (errorCallback && errorNodes.length > 0) {
            errorCallback(errorNodes);
        }
        return valid;
    },
    isDiff: function (notDiffCallback) {
        var diff = this.diffProperties(this.dataOri._source, this.data._source);
        if (diff) {
            return true;
        } else {
            if (notDiffCallback) {
                notDiffCallback();
            }
        }
    },

    diffProperties: function (first, second, diffs) {
        diffs = diffs || {};
        // Compare ref to Object
        for (var attr in second) {
            if (Array.isArray(first[attr]) && Array.isArray(second[attr])) {
                if (first[attr] !== second[attr]) {
                    diffs[attr] = second[attr];
                }
            } else if (typeof first[attr] == 'object' && typeof second[attr] == 'object') {
                // Check recursif
                var subDiffs = this.diffProperties(first[attr], second[attr], {});
                if (subDiffs) {
                    diffs[attr] = subDiffs;
                }
            } else if (first[attr] !== second[attr]) {
                diffs[attr] = second[attr];
            }
        }
        return this.isEmptyObj(diffs) ? undefined : diffs;
    }


});

</script>
</polymer-element>