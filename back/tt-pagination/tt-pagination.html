<!--
A Polymer element for paginating model data, rendering a set of pagination controls for navigating through that serer data.

-->
<link rel="import" href="../components/polymer/polymer.html">


<polymer-element name="tt-pagination" attributes="from size total range">

    <template>
        <link rel="stylesheet" href="../components/bootstrap/dist/css/bootstrap.css" shim-shadowdom>
        <style>
            :host {
                display: block;
            }

        </style>
        <div>from : {{from}}</div>
        <div>size : {{size}}</div>
        <div>total : {{total}}</div>
        <!--<div>currentpage : {{currentpage}}</div>-->
        <div>lastpage : {{lastpage}}</div>
        <ul class="pagination">
            <li on-tap="{{selectPage}}" pageid="first" class="{{currentpage === 1 ? 'disabled' : '' }}"><a>First</a>
            </li>
            <li on-tap="{{selectPage}}" pageid="previous" class="{{currentpage === 1 ? 'disabled' : '' }}">
                <a>&laquo;</a></li>
            <template repeat="{{n in currentRange}}">
                <li on-tap="{{selectPage}}" pageid="{{n}}" class="{{currentpage === n ? 'active' : ''}}">
                    <a>{{n}}
                        <template if="{{currentpage === n }}"><span class="sr-only">(current)</span></template>
                    </a>
                </li>
            </template>
            <li><a on-tap="{{selectPage}}" pageid="next"
                   class="{{currentpage === lastpage ? 'disabled' : '' }}">&raquo;</a></li>
            <li><a on-tap="{{selectPage}}" pageid="last"
                   class="{{currentpage === lastpage ? 'disabled' : '' }}">Last</a></li>
        </ul>

    </template>
    <script>

        Polymer('tt-pagination', {

            firstpage: 1,
            observe: {
                size : 'validateSize'
            },

            ready: function () {
                this.size = this.size || 10;
                this.from = this.from || 0;
                this.currentpage = this._computeCurrentPage(this.from , this.size);
                this.range = this.range || 10;
                this.currentRange = [];
            },

            validateSize : function (oldValue, newValue) {
                if (oldValue!=newValue ) {
                    console.log("validate Size : ", { 'oldValue' : oldValue , 'newValue' : newValue, "current" : this.size });
                    // The from size need to be re calculate
                    this.currentpage = this._computeCurrentPage(this.from, newValue) ;
                    // compute
                    this.lastpage = this._computeLastPage();
                    // Fire Search Event
                    this._firePagingChangeEvent();
                }
            },
            selectPage: function (e, data, sender) {
                var pageid = sender.getAttribute('pageid');
                console.log("select Page : ", pageid);
                // verb control
                switch (pageid) {
                    case "next" :
                        pageid = '+1';
                        break;
                    case "previous" :
                        pageid = '-1';
                        break;
                    case "nextRange" :
                        pageid = '+' + this.range;
                        break;
                    case "previousRange" :
                        pageid = '-' + this.range;
                        break;
                    case "first" :
                        pageid = this.firstpage;
                        break;
                    case "last" :
                        pageid = this.lastpage;
                        break;
                }
                // Do operation
                if ( (typeof pageid === 'string') && pageid.startsWith('+') ) {
                    var inc = parseInt(pageid.substring(1), 10);
                    this.currentpage = Math.min(this.lastpage, this.currentpage + inc);
                } else if ( (typeof pageid === 'string') && pageid.startsWith('-') ) {
                    var inc = parseInt(pageid.substring(1), 10);
                    this.currentpage = Math.max(this.firstpage, this.currentpage - inc);
                } else {
                    this.currentpage = Math.min(Math.max(parseInt(pageid, 10), this.firstpage), this.lastpage);
                }
            },


            totalChanged: function (e, data, sender) {
                this.lastpage = this._computeLastPage();
            },

            lastpageChanged: function () {
                this.currentRange = this._computePageRange();
            },
            rangeChanged: function () {
                this.currentRange = this._computePageRange();
            },

            currentpageChanged: function () {
                this.currentRange = this._computePageRange();
                console.log("-------------- from", (this.currentpage - 1) * this.size);
                this.from = (this.currentpage - 1) * this.size;
                // Fire Search Event
                this._firePagingChangeEvent();
            },

            _firePagingChangeEvent: function () {
                this.fire("change", {
                    "from": this.from,
                    "size": this.size
                });

            },
            _computePageRange: function () {
                var paginations = [];
                // Check currentpage in range
                if (this.currentpage > this.lastpage) {
                    this.currentpage = this.lastpage;
                    return paginations;
                }
                // Range
                var rangeMiddle = Math.ceil(this.range / 2) - 1;
                var rangeMin = Math.max(1, this.currentpage - rangeMiddle);
                var rangeMax = Math.min(this.lastpage, rangeMin + this.range - 1);
                // Compute range in case of reach end
                if (rangeMax - rangeMin < this.range) {
                    rangeMin = Math.max(1, rangeMax - this.range + 1);
                }
                for (var i = rangeMin; i <= rangeMax; i++) {
                    paginations.push(i);
                }

                return paginations;
            },

            _computeLastPage: function () {
                return Math.ceil(this.total / this.size);
            },
            _computeCurrentPage : function (from, size) {
                from = from || this.from;
                size = size || this.size;
                var nextCurrent =   Math.floor(from / size) + 1;
                return isNaN(nextCurrent) ? 0 : nextCurrent;
            }




        });

    </script>


</polymer-element>